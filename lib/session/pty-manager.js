const pty = require('node-pty');
const os = require('os');
const logger = require('../utils/logger');

// Delay before restoring terminal size after mobile disconnect (ms)
const RESTORE_RESIZE_DELAY = 2000;

class PTYManager {
  constructor(tool, workingDir, buffer) {
    this.tool = tool;
    this.workingDir = workingDir;
    this.buffer = buffer;
    this.ptyProcess = null;
    this.onDataCallback = null;
    this.onExitCallback = null;
    this.mobileConnected = false;
    this.localResizeListener = null;
  }

  // Start PTY process
  start(additionalArgs = []) {
    const shell = os.platform() === 'win32' ? 'powershell.exe' : 'bash';
    const args = [...this.tool.args, ...additionalArgs];

    logger.info(`Starting ${this.tool.displayName}...`);
    logger.debug(`Command: ${this.tool.command} ${args.join(' ')}`);
    logger.debug(`Working directory: ${this.workingDir}`);

    try {
      // Disable bracketed paste mode by sending escape sequence
      process.stdout.write('\x1b[?2004l');

      this.ptyProcess = pty.spawn(this.tool.command, args, {
        name: 'xterm-256color',
        cols: process.stdout.columns || 80,
        rows: process.stdout.rows || 24,
        cwd: this.workingDir,
        env: process.env
      });

      logger.success(`${this.tool.displayName} started (PID: ${this.ptyProcess.pid})`);

      // Handle PTY data output
      this.ptyProcess.onData((data) => {
        this.handlePTYOutput(data);
      });

      // Handle PTY exit
      this.ptyProcess.onExit((exitCode) => {
        this.handlePTYExit(exitCode);
      });

      // Setup stdin -> PTY forwarding
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(true);
        process.stdin.setEncoding('utf8');
        process.stdin.resume(); // Make sure stdin is flowing

        process.stdin.on('data', (data) => {
          // Filter out bracketed paste mode sequences
          const filtered = data.toString()
            .replace(/\x1b\[I/g, '') // Focus in
            .replace(/\x1b\[O/g, ''); // Focus out

          if (filtered.length > 0) {
            this.ptyProcess.write(filtered);
          }

          // Handle Ctrl+C
          if (data === '\u0003') { // Ctrl+C
            this.kill();
            process.exit(0);
          }
        });
      }

      // Setup local terminal resize listener
      this.setupLocalResizeListener();

      return true;
    } catch (err) {
      logger.error(`Failed to start ${this.tool.displayName}: ${err.message}`);
      return false;
    }
  }

  // Handle PTY output
  handlePTYOutput(data) {
    // Filter out bracketed paste mode sequences
    // These are generated by the local terminal when it gains/loses focus
    const filtered = data
      .replace(/\x1b\[I/g, '') // Focus in (ESC[I)
      .replace(/\x1b\[O/g, ''); // Focus out (ESC[O)

    // Only process if there's content after filtering
    if (filtered.length > 0) {
      // Show locally
      process.stdout.write(filtered);

      // Add to circular buffer
      this.buffer.append(filtered);

      // Call external callback (for WebSocket transmission)
      if (this.onDataCallback) {
        this.onDataCallback(filtered);
      }
    }
  }

  // Handle PTY exit
  handlePTYExit(exitCode) {
    logger.info(`${this.tool.displayName} exited with code ${exitCode.exitCode}`);

    if (this.onExitCallback) {
      this.onExitCallback(exitCode);
    }
  }

  // Write input to PTY
  write(data) {
    if (this.ptyProcess) {
      this.ptyProcess.write(data);
      return true;
    }
    return false;
  }

  // Resize PTY
  resize(cols, rows) {
    if (this.ptyProcess) {
      this.ptyProcess.resize(cols, rows);
      logger.debug(`PTY resized to ${cols}x${rows}`);
    }
  }

  // Restore PTY size to match local terminal
  restoreLocalSize() {
    const cols = process.stdout.columns || 80;
    const rows = process.stdout.rows || 24;

    logger.info(`Terminal size restored to ${cols}x${rows}`);
    this.resize(cols, rows);
  }

  // Setup listener for local terminal resize events
  setupLocalResizeListener() {
    if (!process.stdout.isTTY) {
      return;
    }

    this.localResizeListener = () => {
      // Only resize PTY if mobile is NOT connected
      // When mobile is connected, PTY follows mobile screen size
      if (!this.mobileConnected) {
        const cols = process.stdout.columns || 80;
        const rows = process.stdout.rows || 24;

        logger.debug(`Local terminal resized to ${cols}x${rows}, updating PTY`);
        this.resize(cols, rows);
      } else {
        logger.debug('Local terminal resized, but mobile is connected - ignoring');
      }
    };

    // Listen for terminal resize events (SIGWINCH)
    process.stdout.on('resize', this.localResizeListener);
    logger.debug('Local terminal resize listener installed');
  }

  // Set mobile connection state
  setMobileConnected(connected) {
    this.mobileConnected = connected;
    logger.debug(`Mobile connection state: ${connected ? 'connected' : 'disconnected'}`);
  }

  // Set data callback (for sending to WebSocket)
  onData(callback) {
    this.onDataCallback = callback;
  }

  // Set exit callback
  onExit(callback) {
    this.onExitCallback = callback;
  }

  // Kill PTY process
  kill() {
    if (this.ptyProcess) {
      logger.debug('Killing PTY process');
      this.ptyProcess.kill();
      this.ptyProcess = null;
    }

    // Remove local resize listener
    if (this.localResizeListener && process.stdout.off) {
      process.stdout.off('resize', this.localResizeListener);
      this.localResizeListener = null;
      logger.debug('Local terminal resize listener removed');
    }

    // Restore stdin
    if (process.stdin.isTTY && process.stdin.setRawMode) {
      process.stdin.setRawMode(false);
    }
  }

  // Check if PTY is running
  isRunning() {
    return this.ptyProcess !== null;
  }

  // Get PTY PID
  getPid() {
    return this.ptyProcess ? this.ptyProcess.pid : null;
  }
}

module.exports = PTYManager;
module.exports.RESTORE_RESIZE_DELAY = RESTORE_RESIZE_DELAY;
