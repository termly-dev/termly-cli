const pty = require('node-pty');
const os = require('os');
const crypto = require('crypto');
const logger = require('../utils/logger');

// Delay before restoring terminal size after mobile disconnect (ms)
const RESTORE_RESIZE_DELAY = 2000;

class PTYManager {
  constructor(tool, workingDir, buffer) {
    this.tool = tool;
    this.workingDir = workingDir;
    this.buffer = buffer;
    this.ptyProcess = null;
    this.onDataCallback = null;
    this.onExitCallback = null;
    this.mobileConnected = false;
    this.localResizeListener = null;
    this.outputPaused = false; // Flag to pause PTY output during reconnection

    // Deduplication state (for Windows cmd.exe duplicate output bug)
    // Use sliding window with hashes for more robust duplicate detection
    this.recentOutputs = []; // Array of {hash, timestamp} objects
    this.duplicateThresholdMs = 150; // Duplicates within 150ms are filtered
    this.maxRecentOutputs = 10; // Keep last 10 outputs for comparison
  }

  // Start PTY process
  start(additionalArgs = []) {
    const isWindows = os.platform() === 'win32';
    const args = [...this.tool.args, ...additionalArgs];

    logger.info(`Starting ${this.tool.displayName}...`);
    logger.debug(`Command: ${this.tool.command} ${args.join(' ')}`);
    logger.debug(`Working directory: ${this.workingDir}`);

    try {
      // Disable bracketed paste mode by sending escape sequence
      process.stdout.write('\x1b[?2004l');

      // On Windows, spawn commands through cmd.exe to handle .cmd/.bat files
      let spawnCommand = this.tool.command;
      let spawnArgs = args;

      if (isWindows) {
        // Use cmd.exe to spawn the command (handles .cmd/.bat files)
        spawnCommand = 'cmd.exe';
        spawnArgs = ['/c', this.tool.command, ...args];
      }

      logger.debug(`Spawn command: ${spawnCommand} ${spawnArgs.join(' ')}`);

      this.ptyProcess = pty.spawn(spawnCommand, spawnArgs, {
        name: 'xterm-256color',
        cols: process.stdout.columns || 80,
        rows: process.stdout.rows || 24,
        cwd: this.workingDir,
        env: process.env
      });

      logger.success(`${this.tool.displayName} started (PID: ${this.ptyProcess.pid})`);

      // Handle PTY data output
      this.ptyProcess.onData((data) => {
        this.handlePTYOutput(data);
      });

      // Handle PTY exit
      this.ptyProcess.onExit((exitCode) => {
        this.handlePTYExit(exitCode);
      });

      // Setup stdin -> PTY forwarding
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(true);
        process.stdin.setEncoding('utf8');
        process.stdin.resume(); // Make sure stdin is flowing

        process.stdin.on('data', (data) => {
          // Filter out bracketed paste mode sequences
          const filtered = data.toString()
            .replace(/\x1b\[I/g, '') // Focus in
            .replace(/\x1b\[O/g, ''); // Focus out

          if (filtered.length > 0) {
            this.ptyProcess.write(filtered);
          }

          // Handle Ctrl+C
          if (data === '\u0003') { // Ctrl+C
            this.kill();
            process.exit(0);
          }
        });
      }

      // Setup local terminal resize listener
      this.setupLocalResizeListener();

      return true;
    } catch (err) {
      logger.error(`Failed to start ${this.tool.displayName}: ${err.message}`);
      return false;
    }
  }

  // Convert data to hex dump for debugging
  toHexDump(data, maxLength = 200) {
    const bytes = Buffer.from(data, 'utf8');
    const hex = bytes.toString('hex').match(/.{1,2}/g)?.join(' ') || '';
    const truncated = hex.length > maxLength ? hex.substring(0, maxLength) + '...' : hex;
    return truncated;
  }

  // Escape special characters for logging
  escapeSpecialChars(data) {
    return data
      .replace(/\r/g, '\\r')
      .replace(/\n/g, '\\n')
      .replace(/\t/g, '\\t')
      .replace(/\x1b/g, '\\x1b')
      .replace(/\x00/g, '\\x00');
  }

  // Handle PTY output
  handlePTYOutput(data) {
    // Detailed logging for debugging Windows vs Mac differences
    if (process.env.DEBUG === '1' || process.argv.includes('--debug')) {
      logger.debug(`PTY Raw Output (${data.length} bytes):`);
      logger.debug(`  Text: ${this.escapeSpecialChars(data.substring(0, 100))}`);
      logger.debug(`  Hex:  ${this.toHexDump(data)}`);
    }

    // Filter out bracketed paste mode sequences
    // These are generated by the local terminal when it gains/loses focus
    let filtered = data
      .replace(/\x1b\[I/g, '') // Focus in (ESC[I)
      .replace(/\x1b\[O/g, ''); // Focus out (ESC[O)

    // Log filtered result if different
    if (filtered !== data && (process.env.DEBUG === '1' || process.argv.includes('--debug'))) {
      logger.debug(`PTY Filtered (${filtered.length} bytes):`);
      logger.debug(`  Text: ${this.escapeSpecialChars(filtered.substring(0, 100))}`);
    }

    // Only process if there's content after filtering
    if (filtered.length > 0) {
      // Deduplicate output (Windows cmd.exe bug workaround)
      // cmd.exe can generate duplicate PTY output events in rapid succession
      // Only apply deduplication on Windows to avoid false positives on Unix
      // If duplicate found, skip output to BOTH local terminal and mobile
      if (os.platform() === 'win32') {
        const now = Date.now();

        // Create hash of the output for reliable comparison
        const hash = crypto.createHash('sha256').update(filtered).digest('hex');

        // Clean up old entries outside the time window
        this.recentOutputs = this.recentOutputs.filter(
          entry => now - entry.timestamp < this.duplicateThresholdMs
        );

        // Check if this hash exists in recent outputs
        const duplicate = this.recentOutputs.find(entry => entry.hash === hash);

        if (duplicate) {
          const timeSinceDuplicate = now - duplicate.timestamp;
          if (process.env.DEBUG === '1' || process.argv.includes('--debug')) {
            logger.debug(`Dedup check: ${timeSinceDuplicate}ms since duplicate, hash match: true`);
            logger.debug(`>>> DUPLICATE SKIPPED (both local and mobile)`);
          }
          // Skip output to both local terminal and mobile
          return;
        }

        // Log if in debug mode
        if (process.env.DEBUG === '1' || process.argv.includes('--debug')) {
          logger.debug(`Dedup check: no duplicate found, hash: ${hash.substring(0, 16)}...`);
        }

        // Add to recent outputs
        this.recentOutputs.push({ hash, timestamp: now });

        // Limit the size of recent outputs array
        if (this.recentOutputs.length > this.maxRecentOutputs) {
          this.recentOutputs.shift();
        }
      }

      // Show locally (unless output is paused during reconnection)
      // Local output gets original filtered data (no escape code normalization)
      if (!this.outputPaused) {
        process.stdout.write(filtered);
      }

      // Prepare data for mobile transmission with Windows-specific normalization
      let forMobile = filtered;

      // Windows workaround: normalize screen clear escape sequences for mobile only
      // Windows Claude Code uses \x1b[H\x1b[K (home + clear line) for screen redraws
      // Mac uses \x1b[2J\x1b[3J\x1b[H (clear screen + clear scrollback + home)
      // Replace Windows pattern with Mac pattern for consistent mobile rendering
      // Local PowerShell output is NOT affected - it gets original escape codes
      if (os.platform() === 'win32' && forMobile.startsWith('\x1b[H\x1b[K')) {
        forMobile = '\x1b[2J\x1b[3J\x1b[H' + forMobile.slice(6);
        if (process.env.DEBUG === '1' || process.argv.includes('--debug')) {
          logger.debug('Normalized Windows screen clear for mobile (\\x1b[2J\\x1b[3J\\x1b[H)');
        }
      }

      // Add to circular buffer (with normalized data for mobile)
      this.buffer.append(forMobile);

      // Call external callback for WebSocket transmission (with normalized data)
      if (this.onDataCallback) {
        this.onDataCallback(forMobile);
      }
    }
  }

  // Handle PTY exit
  handlePTYExit(exitCode) {
    logger.info(`${this.tool.displayName} exited with code ${exitCode.exitCode}`);

    if (this.onExitCallback) {
      this.onExitCallback(exitCode);
    }
  }

  // Write input to PTY
  write(data) {
    if (this.ptyProcess) {
      // Log input for debugging
      if (process.env.DEBUG === '1' || process.argv.includes('--debug')) {
        logger.debug(`PTY Input (${data.length} bytes):`);
        logger.debug(`  Text: ${this.escapeSpecialChars(data.substring(0, 100))}`);
        logger.debug(`  Hex:  ${this.toHexDump(data)}`);
      }

      this.ptyProcess.write(data);
      return true;
    }
    return false;
  }

  // Resize PTY
  resize(cols, rows) {
    if (this.ptyProcess) {
      this.ptyProcess.resize(cols, rows);
      logger.debug(`PTY resized to ${cols}x${rows}`);
    }
  }

  // Restore PTY size to match local terminal
  restoreLocalSize() {
    const cols = process.stdout.columns || 80;
    const rows = process.stdout.rows || 24;

    // Only show on console in debug mode, but always log to file
    logger.debugInfo(`Terminal size restored to ${cols}x${rows}`);
    this.resize(cols, rows);
  }

  // Setup listener for local terminal resize events
  setupLocalResizeListener() {
    if (!process.stdout.isTTY) {
      return;
    }

    this.localResizeListener = () => {
      // Only resize PTY if mobile is NOT connected
      // When mobile is connected, PTY follows mobile screen size
      if (!this.mobileConnected) {
        const cols = process.stdout.columns || 80;
        const rows = process.stdout.rows || 24;

        logger.debug(`Local terminal resized to ${cols}x${rows}, updating PTY`);
        this.resize(cols, rows);
      } else {
        logger.debug('Local terminal resized, but mobile is connected - ignoring');
      }
    };

    // Listen for terminal resize events (SIGWINCH)
    process.stdout.on('resize', this.localResizeListener);
    logger.debug('Local terminal resize listener installed');
  }

  // Set mobile connection state
  setMobileConnected(connected) {
    this.mobileConnected = connected;
    logger.debug(`Mobile connection state: ${connected ? 'connected' : 'disconnected'}`);
  }

  // Set data callback (for sending to WebSocket)
  onData(callback) {
    this.onDataCallback = callback;
  }

  // Set exit callback
  onExit(callback) {
    this.onExitCallback = callback;
  }

  // Kill PTY process
  kill() {
    if (this.ptyProcess) {
      logger.debug('Killing PTY process');
      this.ptyProcess.kill();
      this.ptyProcess = null;
    }

    // Remove local resize listener
    if (this.localResizeListener && process.stdout.off) {
      process.stdout.off('resize', this.localResizeListener);
      this.localResizeListener = null;
      logger.debug('Local terminal resize listener removed');
    }

    // Restore stdin
    if (process.stdin.isTTY && process.stdin.setRawMode) {
      process.stdin.setRawMode(false);
    }
  }

  // Check if PTY is running
  isRunning() {
    return this.ptyProcess !== null;
  }

  // Get PTY PID
  getPid() {
    return this.ptyProcess ? this.ptyProcess.pid : null;
  }

  // Pause PTY output (used during reconnection to prevent UI interference)
  pauseOutput() {
    this.outputPaused = true;
    logger.debug('PTY output paused');
  }

  // Resume PTY output
  resumeOutput() {
    this.outputPaused = false;
    logger.debug('PTY output resumed');
  }
}

module.exports = PTYManager;
module.exports.RESTORE_RESIZE_DELAY = RESTORE_RESIZE_DELAY;
